<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brain Model Diagnostic</title>
    <style>
        body { margin: 0; overflow: hidden; background: #1a1a2e; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: monospace;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            font-size: 12px;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div id="info">Loading diagnostics...</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        const info = document.getElementById('info');
        let diagnosticInfo = [];

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 3);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        
        // Simple controls - NO auto-rotate
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = false; // Disable damping
        controls.autoRotate = false;    // Disable auto-rotate
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(5, 5, 5);
        scene.add(dirLight);
        
        // Load model
        const loader = new THREE.GLTFLoader();
        loader.load('public/brain.glb', (gltf) => {
            const model = gltf.scene;
            
            // Analyze model structure
            let meshCount = 0;
            let materialCount = 0;
            let transparentCount = 0;
            let doubleSidedCount = 0;
            
            model.traverse((child) => {
                if (child.isMesh) {
                    meshCount++;
                    
                    if (child.material) {
                        materialCount++;
                        if (child.material.transparent) transparentCount++;
                        if (child.material.side === THREE.DoubleSide) doubleSidedCount++;
                        
                        // FIX: Force all materials to be opaque and front-sided
                        child.material.transparent = false;
                        child.material.opacity = 1.0;
                        child.material.side = THREE.FrontSide;
                        child.material.depthWrite = true;
                        child.material.depthTest = true;
                        child.material.needsUpdate = true;
                    }
                    
                    // Disable frustum culling
                    child.frustumCulled = false;
                }
            });
            
            diagnosticInfo.push(`Meshes: ${meshCount}`);
            diagnosticInfo.push(`Materials: ${materialCount}`);
            diagnosticInfo.push(`Transparent: ${transparentCount}`);
            diagnosticInfo.push(`DoubleSided: ${doubleSidedCount}`);
            diagnosticInfo.push(`---`);
            diagnosticInfo.push(`Auto-rotate: OFF`);
            diagnosticInfo.push(`Damping: OFF`);
            diagnosticInfo.push(`Frustum culling: OFF`);
            
            // Center and scale
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 1.5 / maxDim;
            
            model.scale.setScalar(scale);
            model.position.sub(center.multiplyScalar(scale));
            
            scene.add(model);
            
            info.innerHTML = diagnosticInfo.join('<br>');
        }, undefined, (error) => {
            info.innerHTML = 'ERROR: ' + error.message;
        });
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
